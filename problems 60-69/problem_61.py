# Problem 61
# Cyclical figurate numbers

"""
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
are all figurate (polygonal) numbers and
are generated by the following formulae:

Triangle        P3,n=n(n+1)/2       1, 3, 6, 10, 15, ...
Square      P4,n=n2         1, 4, 9, 16, 25, ...
Pentagonal      P5,n=n(3n-1)/2      1, 5, 12, 22, 35, ...
Hexagonal       P6,n=n(2n-1)        1, 6, 15, 28, 45, ...
Heptagonal      P7,n=n(5n-3)/2      1, 7, 18, 34, 55, ...
Octagonal       P8,n=n(3n-2)        1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers:
8128, 2882, 8281, has three interesting properties.

    The set is cyclic, in that the last two digits of each number
    is the first two digits of the next number
    (including the last number with the first).

    Each polygonal type: triangle (P3,127=8128),
    square (P4,91=8281), and pentagonal (P5,44=2882),
    is represented by a different number in the set.

    This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers
for which each polygonal type:
triangle, square, pentagonal, hexagonal, heptagonal, and octagonal,
is represented by a different number in the set.
"""


def getNthTriangle(n):
    return n*(n+1)/2


def getNthSquare(n):
    return n*n


def getNthPentagonal(n):
    return n*(3*n-1)/2


def getNthHexagonal(n):
    return n*(2*n-1)


def getNthHeptagonal(n):
    return n*(5*n-3)/2


def getNthOctagonal(n):
    return n*(3*n-2)


def getNumberList(getFigure):
    t = 0
    n = 1
    figures = []

    while t < 10000:
        t = getFigure(n)

        if t >= 1000 and t < 10000:
            figures.append(str(t))

        n += 1

    return figures


def getTwoDigitsLeft(n):
    return n[0:2]


def getTwoDigitsRight(n):
    return n[-2:]

"""
Dada la string solucion, divido y hago la suma para resolver el problema
"""
def respuesta(cadena):
    contador = 0
    # La solucion es la suma de 6 numeros de 4 digitos
    for i in range(0, 24, 4):
        print cadena[i:i+4]
        contador += int(cadena[i:i+4])

    return contador


def algoritmoPrincipal():
    triangles = getNumberList(getNthTriangle)
    squares = getNumberList(getNthSquare)
    pentagons = getNumberList(getNthPentagonal)
    hexagons = getNumberList(getNthHexagonal)
    heptagons = getNumberList(getNthHeptagonal)
    octagons = getNumberList(getNthOctagonal)

    poligons = [triangles, squares, pentagons, hexagons, heptagons, octagons]

    # Como tengo que encontrar ciclicos, puedo empezar por cualquiera,
    # Elijo triangulos por elegir alguno. Con todos da la misma respuesta.
    encontrarCiclico(triangles, "", poligons)


# Resuelvo recursivamente
def encontrarCiclico(poli, _cadenaActual, _poligonos):
    poligonos = list(_poligonos) #Quiero modificar una copia
    poligonos.remove(poli)

    for p in poli:
        # Uso una copia de cadena para no perder si necesito volver atras
        cadenaActual = _cadenaActual[:]

        if (cadenaActual == "") or (getTwoDigitsLeft(p) == getTwoDigitsRight(cadenaActual)):
            cadenaActual += p

            # Si ya no quedan mas poligonos, entonces es ciclico y es solucion
            if len(poligonos) == 0:
                if getTwoDigitsRight(cadenaActual) == getTwoDigitsLeft(cadenaActual):
                    print "RESPUESTA: " + str(respuesta(cadenaActual))
                    return

            else:
                for poli2 in poligonos:
                    encontrarCiclico(poli2, cadenaActual, poligonos)

    return


def main():
    algoritmoPrincipal()


if __name__ == "__main__":
    main()
